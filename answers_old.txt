Exercise 1. The char array reqpath, which is allocated in process_client() (in zookd.c), can overflow. Since reqpath is not marked as static, it is allocated on the stack. 

Notice that reqpath is 4096 bytes large and is passed into http_request_line() (as a char pointer). Inside http_request_line(), reqpath is forwarded into url_decode(), which decodes the URI in sp2, storing the result in reqpath. However, if sp2 is more than 4096 bytes, then the reqpath buffer will overflow. 

To overwrite the return address of process_client(), the HTTP request should contain a URI that is larger than 4096 bytes. It must be large enough to not only fill the 4096 bytes of reqpath but also the other variables stored on the stack between reqpath and the return address, such as the caller function's base pointer.

Moreover, to ensure that http_request_line() does not return prematurely, we must ensure that the HTTP request is generally structured correctly (e.g., the URI must begin with a slash, the request type must be GET or POST). The URI also cannot be too long; otherwise, the 8196 byte buf in http_request_line() will overflow, which will cut out the HTTP/[VER] part of the HTTP request and cause the function to return with "Cannot parse HTTP request (2)" before the buffer overflow occurs. 

Thus, a request like:

b"GET \xFF\xFF...\xFF HTTP/1.0\r\n\r\n" 

should work, where b"\xFF" is repeated 6000 times in the URI (6000 byte URI). When the buffer overflows, the call stack will have main() at the bottom, run_server() above that, process_client() above that, http_request_line() above that, and url_decode() above that. The reqpath buffer will overflow in url_decode(). Then url_decode() will return and pop off the stack; then http_request_line() will pop off the stack(), leaving process_client() at the top. process_client()'s return address will have been overwritten, which means we can return to a different address than intended.
