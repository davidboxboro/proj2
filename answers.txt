Exercise 1. 

The char array named value, which is allocated in http_request_headers(), can overflow. Since value is not marked as static, it is allocated on the stack. 

Notice that value is 512 bytes long, and sp (which contains a value in the HTTP header) is decoded and copied into value in url_decode(). This means that if sp (and the corresponding HTTP header value) is too long, value will overflow.

The address of value is 0x7fffffffda50. Inside http_request_headers(), the return address is saved at 0x7fffffffdc88. The difference is 0x238 = 568, so if sp is more than 568 bytes long, then the return address will be overwritten. 

Thus, a request like:

b"GET / HTTP/1.0\r\n" + 
b"A" * 568 + struct.pack("<Q", 0xAAAABBBBCCCC) + b"\r\n" + 
b"\r\n"

should work. Here, the b"A" bytes pad the value in the HTTP request up to the return address location and 0xAAAABBBBCCCC overwrites the original return address.

The call stack is as follows. From process_client(), http_request_headers() is called and its frame is pushed onto the stack. Inside http_request_headers(), the value char array is allocated on the stack and url_decode() is called, so url_decode()'s frame is pushed onto the stack. sp and value are passed into url_decode(), and if sp is sufficiently long (as detailed above), the decoded HTTP request value will be copied beyond the 512 bytes allocated on the stack for value and overwrite the return address of http_request_headers(). When url_decode() returns, it pops off the stack, and when http_request_headers() returns, it returns to a new location because of the overwritten return address.

##########

Exercise 6. 

One vulnerability is that the attacker can read files on the server that users should probably not have access to. In particular, the attacker can include a series of "../" in the HTTP request URI. This enables the attacker to access files outside the scope of the /home/student/lab directory. For example, by issuing a "GET /../../../etc/passwd HTTP/1.0" request, the server will return the contents of /etc/passwd to the user, which contains possibly sensitive information about the system. Other files may contain passwords or private keys. However, this attack would require the attacker to know (or guess) the locations of sensitive files on the server, so that they can structure their request URI correctly. The attack works because the server responds to HTTP requests by concatenating the current working directory with the request URI, and reads the content at that path (see http_serve()). One way to fix this vulnerability is to make a list of files that clients are able to access and check that the requested file is one of these listed files; if the request URI refers to a file the user is not authorized to access, the web server should return an error response. Another approach is to chroot the process in a jail directory (so that clients cannot access files outside of that directory); the directory itself should not contain any sensitive files and should not have setuid executables. Here, it can be useful to use the principle of least privilege, so that web server processes are only allowed to access the bare minimum needed to function correctly. Another strategy is to store user data, passwords, and other sensitive information on another virtual machine, which can communicate with the web server via RPCs. This can make it harder to an attacker to read the contents of sensitive files. I tried this attack myself and it worked fine.   

Another vulnernability is that the attacker can execute executable files on the server, especially ones that they probably should not have access to. This can lead to significant damage on the server (depending on what executables are available). As an example, suppose a reset_grades.sh bash executable existed on the server (say in /home/student), which clears the grades.txt file. (Suppose the first line is #!/usr/bin/bash so that execve knows how to execute it.) Then "GET /../reset_grades.sh HTTP/1.0" would cause http_serve_executable() to be called and reset_grades.sh to be executed, thus clearing grades.txt. Alternatively, by executing /usr/bin/sh, http_serve_executable() will call fork() and execute the shell command. Since the child process will not terminate, the parent hangs without returning to the client. This is bad because the server is wasting resources and may not be able to serve additional clients. I tested both of these executable attack variations and they worked fine. The attack works because the server is not checking to see what executable is being run before running it. One limitation is that the attacker is restricted to executables that are on the server; this means that the attacker must know the location of the executable of interest and find a way to use existing executables to inflict the most damage possible. Additionally, files not marked as executable (+x) with not invoke http_serve_executable() and thus will not be executed. One way to fix this vulnerability is to perform a check on the executable file name before executing it; the server needs to make sure that it is a file that is intended for handling HTTP requests for the web service. It can also chroot the process in a jail directory, so that executables in /usr/bin and other locations on the system are not accessible. Another approach is to isolate different parts of the system; for example, user data can be stored on a different machine, so that it is harder to attackers to run malicious code that may modify or delete user data. 
